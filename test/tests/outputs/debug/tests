[Tests]
  issues = '#1927'
  [show_var_residual_norms]
    type = 'RunApp'
    input = 'show_var_residual_norms.i'
    expect_out = "\|residual\|_2 of individual variables:.*\|residual\|_2 of individual variables:.*\|residual\|_2 of individual variables:"

    requirement = "The system shall be include the ability to display variable residual norms."
    design = "VariableResidualNormsDebugOutput.md"
  []

  [show_var_residual_norms_debug]
    type = 'RunApp'
    input = 'show_var_residual_norms_debug.i'
    expect_out = "\|residual\|_2 of individual variables:.*\|residual\|_2 of individual variables:.*\|residual\|_2 of individual variables:"

    requirement = "The system shall include debug syntax that includes the ability to enable variable residual norm output."
    design = "VariableResidualNormsDebugOutput.md Debug/index.md"
  []

  [show_material_props]
    type = RunApp
    input = show_material_props.i
    expect_out = "Property Names:.*\"bnd_prop\""

    requirement = "The system shall be include the ability to display material property information."
    design = "MaterialPropertyDebugOutput.md"
  []

  [show_material_props_block]
    type = RunApp
    input = show_material_props_debug.i
    expect_out = "Property Names:.*\"bnd_prop\""

    requirement = "The system shall include debug syntax that includes the ability to enable material property information output."
    design = "MaterialPropertyDebugOutput.md Debug/index.md"
  []

  [show_top_residuals]
    type = RunApp
    input = show_top_residuals.i
    expect_out = "\[DBG\]\[\d+\].*'u'.*at node"
    max_parallel = 1

    requirement = "The system shall be include the ability to display residual information for variables."
    design = "TopResidualDebugOutput.md"
  []

  [show_top_residuals_debug]
    # Test that top residuals are displayed using DebugOutput object via Debug block
    type = RunApp
    input = show_top_residuals_debug.i
    expect_out = "'u' in subdomain\(s\) {'block_one'}.*at node.*'v' in subdomain\(s\) {'block_one'}.*at element.*'w' \(SCALAR\)"
    max_parallel = 1

    requirement = "The system shall include debug syntax that includes the ability to enable variable residual information."
    design = "TopResidualDebugOutput.md Debug/index.md"
  []

  [show_top_residuals_nonlinear_only]
    # Test that top residuals may be limited to nonlinear iterations only
    type = RunApp
    input = show_top_residuals_nonlinear_only.i
    expect_out = "0 Linear[^*\n]**\n[^*\n]*1 Linear"
    max_parallel = 1

    requirement = "The system shall be include the ability to display residual information for variables that is limited to non-linear iterations."
    design = "TopResidualDebugOutput.md"
  []

  [show_top_residuals_scalar]
    # Test that top residuals of scalar variables are displayed using DebugOutput object via Outputs block
    type = RunApp
    input = show_top_residuals_scalar.i
    expect_out = "\[DBG\]\[\d+\].*'lambda' \(SCALAR\)"
    max_parallel = 1

    requirement = "The system shall be include the ability to display residual information for scalar variables."
    design = "TopResidualDebugOutput.md"
  []

  [show_material_properties_consumed]
    type = RunApp
    input = show_material_props_consumed.i
    expect_out = "Object: Kernel::diff2\s+Properties: andrew"

    requirement = "The system shall include debug syntax that includes material property consumption information."
    design = "MaterialPropertyDebugOutput.md Debug/index.md"
  []

  [show_execution_order]
    # These tests are designed to make sure the ordering of objects is always printed the same way
    # They may diff if that ordering actually changes, in which case a regold may be necessary
    # However, they do not test the explanation text also provided by these logs, as it is expected
    # this text will change over time both as new objects/systems are added and as we refine the
    # explanations to make them clearer
    requirement = 'The system shall include the ability to output the execution order of'
    design = 'Debug/index.md'
    [regular_kernels_bcs]
      type = RunApp
      input = 'show_execution_kernels_bcs.i'
      expect_out = '\[DBG\] bc_u_tb bc_ul bc_ur bc_ut bc_ub '
      detail = 'objects contributing to the residual and Jacobian, notably regular kernels and boundary conditions'
    []
    [fv_kernels_bcs]
      type = RunApp
      input = 'show_execution_fv_flux_objects.i'
      expect_out = '\[DBG\]  2_burger 1_burgers'
      detail = 'finite volume flux objects contributing to the residual and Jacobian, notably finite volume flux kernels and flux boundary conditions'
    []
    [nodal_kernel_bcs]
      type = RunApp
      input = 'show_execution_nodal_kernels_bcs.i'
      expect_out = '\[DBG\] source bc_all '
      detail = 'nodal objects contributing to the residual, notably nodal kernels and boundary conditions'
    []
    # These three tests make sure the targetting of a single execution flag works
    [user_objects_initial]
      type = RunApp
      input = 'show_execution_userobjects.i'
      cli_args = 'Debug/show_execution_order=INITIAL UserObjects/find_node/execute_on=INITIAL UserObjects/side_int/execute_on=INITIAL UserObjects/values/execute_on=INITIAL'
      expect_out = '\[DBG\] values'
      detail = 'user objects, including postprocessors, executed at the beginning of the simulation'
    []
    [user_objects_timestep_begin_end]
      type = RunApp
      input = 'show_execution_userobjects.i'
      cli_args = "Debug/show_execution_order='TIMESTEP_BEGIN TIMESTEP_END'"
      expect_out = 'h L2u H1error H1Semierror L2v_elem f_integral elem_sample'
      detail = 'user objects, including postprocessors, executed at the beginning and end of each time step'
    []
    [user_objects_transfers]
      type = RunApp
      input = 'show_execution_userobjects.i'
      cli_args = 'MultiApps/active=full_solve Transfers/active=conservative Debug/show_execution_order=TRANSFER'
      expect_out = '\[DBG\] Computing elemental user objects on TRANSFER'
      detail = 'user objects, including postprocessors, executed on transfers between applications'
    []
    # This should be useful if an indicator is executed after a marker, by accident
    [adaptivity]
      type = RunApp
      input = 'show_execution_adaptivity.i'
      expect_out = '\[DBG\] indicator'
      detail = 'each step of the adaptive refinement process'
    []
    # Initial conditions use dependency resolution at node/element scale to execute
    [initial_conditions]
      type = RunApp
      input = 'show_execution_ics.i'
      expect_out = '\[DBG\] a_ic u_ic v_ic b_ic ghost_ic test_var_ic power'
      detail = 'initial conditions of variables'
    []
    # Auxiliary kernels could be misordered easily, it is one of the most important goals of this
    # debug log to make sure chains of auxkernels are in the right order
    [auxkernels]
      type = RunApp
      input = 'show_execution_auxkernels.i'
      expect_out = '\[DBG\] b_saux c_saux '
      detail = 'auxiliary kernels intermingled with initial conditions and user objects'
    []
  []
[]
